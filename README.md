# CS61C

### Lab 01

- `scp <source> <destination>`

使用 ssh 进行复制

- 使用 cgdb

**《gdb高级调试教程》**

由于使用 cgdb 自带了窗口，所以 list 就不必要了。

| 命令          | 效果                                             |
| ------------- | ------------------------------------------------ |
| r             | 运行至下一个断点                                 |
| b+行号/函数名 | 添加断点                                         |
| info b        |                                                  |
| bt            | 查看当前线程堆栈                                 |
| c             | 继续运行                                         |
| finish        | 直接执行完当前函数返回                           |
| n             | 单步步过（不进入函数）                           |
| s             | 单步步入                                         |
| display       | 每次暂停，打印监视的变量的值（info/del display） |
| print         |                                                  |

其中 info 有很多组合

- info locals
- info functions
- info args

- 详见 help info

### lab03

- la指令是什么

给一个寄存器赋予一个标签的地址

[详解risc-v的la指令 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/367085156)

- li

同 la 都是伪指令

- ret (jalr x0, ra)

[RISC-V汇编语言入门（六） —RV32I指令集 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/540887151)

### lab04

- 对于 t 类寄存器，我们如果想在调用函数后继续使用，必须将其保证在栈中
- 对于 s 类寄存器，我们可以直接在调用函数后继续使用，因为其在调用的函数中**将会被还原**（如果使用）

### proj2

项目要求我们用汇编实现一个简单的线性神经网络，项目难度并不高，写完之后对 RISC-V 汇编更加熟悉了。在感受到汇编无与伦比的灵活性时，也不禁怀念起了高级语言。

- **对于 a 类寄存器，可以在开头用 s 类寄存器缓存起来，这样就不用频繁入栈出栈了**
- 寄存器没有地址，CPU 内部靠编号取值
- 空间的使用非常灵活，比如：可以为每一个矩阵多申请 4 字节来存放元素数量
- 官方在 `util.s` 封装了一层 ecall 调用，让使用系统调用的时候更方便了
- 写到这里基本已经熟悉了汇编的写法，所以并未遇到太多难点

